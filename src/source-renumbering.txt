import fs from 'fs';
import path from 'path';

export interface SourceInfo {
    originalId: number;
    newId: number;
    url: string;
    title?: string;
    fileName: string;
}

export interface ProcessedFileContent {
    content: string;
    sources: SourceInfo[];
  }
  
  export interface DimensionWithSources {
    dimension: string;
    combinedContent: string;
    allSources: SourceInfo[];
    files: any[];
  }
  
  /**
   * ê°œë³„ íŒŒì¼ì˜ ì†ŒìŠ¤ë¥¼ íŒŒì‹±í•˜ê³  ì¬ì •ë ¬í•˜ëŠ” í•¨ìˆ˜
   */
  export function processFileWithSourceRenumbering(
    fileContent: string,
    fileName: string,
    startingNumber: number
  ): ProcessedFileContent {
    
    // Sources ì„¹ì…˜ ë¶„ë¦¬
    const parts = fileContent.split(/---\s*\n\s*\*?\*?Sources?\*?\*?:?\s*\n/);
    const mainContent = parts[0] || '';
    const sourcesSection = parts[1] || '';
    
    // Sources ì„¹ì…˜ì—ì„œ ì†ŒìŠ¤ ì •ë³´ ì¶”ì¶œ
    const sourceMap = new Map<number, { url: string; title?: string }>();
    
    if (sourcesSection) {
      const sourceLines = sourcesSection.split('\n').filter(line => line.trim());
      
      sourceLines.forEach(line => {
        const match = line.match(/(\d+)\.\s*(.+?)(?:\s*-\s*(https?:\/\/[^\s]+))?\s*$/);
        if (match) {
          const originalId = parseInt(match[1]);
          const titleOrUrl = match[2]?.trim() || '';
          const url = match[3] || (titleOrUrl.startsWith('http') ? titleOrUrl : '');
          const title = match[3] ? titleOrUrl : undefined;
          
          if (url) {
            sourceMap.set(originalId, { url, title });
          }
        }
      });
    }
    
    // ë³¸ë¬¸ì—ì„œ ì‚¬ìš©ëœ ì¸ìš© ë²ˆí˜¸ ì°¾ê¸° ë° ë§¤í•‘
    const citationPattern = /\[(\d+)\]/g;
    const usedSources = new Set<number>();
    const sourceMapping = new Map<number, number>();
    let currentNewNumber = startingNumber;
    
    let match: RegExpExecArray | null;
    while ((match = citationPattern.exec(mainContent)) !== null) {
      const originalId = parseInt(match[1]);
      usedSources.add(originalId);
    }
    
    const sortedUsedSources = Array.from(usedSources).sort((a, b) => a - b);
    const finalSources: SourceInfo[] = [];
    
    sortedUsedSources.forEach(originalId => {
      const sourceInfo = sourceMap.get(originalId);
      if (sourceInfo) {
        sourceMapping.set(originalId, currentNewNumber);
        finalSources.push({
          originalId,
          newId: currentNewNumber,
          url: sourceInfo.url,
          title: sourceInfo.title,
          fileName
        });
        currentNewNumber++;
      }
    });
    
    // ë³¸ë¬¸ì˜ ì¸ìš© ë²ˆí˜¸ë¥¼ ìƒˆ ë²ˆí˜¸ë¡œ êµì²´
    let processedContent = mainContent;
    sourceMapping.forEach((newId, originalId) => {
      const originalPattern = new RegExp(`\\[${originalId}\\]`, 'g');
      processedContent = processedContent.replace(originalPattern, `[${newId}]`);
    });
    
    return {
      content: processedContent.trim(),
      sources: finalSources
    };
  }
  
  /**
   * Dimension ê·¸ë£¹ì˜ ëª¨ë“  íŒŒì¼ì— ëŒ€í•´ ì†ŒìŠ¤ ë„˜ë²„ë§ì„ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
   */
  export function processDimensionGroupWithSources(group: any): DimensionWithSources {
    let combinedContent = '';
    const allSources: SourceInfo[] = [];
    let currentStartingNumber = 1;
    
    console.log(`ğŸ”„ Processing ${group.files.length} files for ${group.dimension}`);
    
    group.files.forEach((file: any, index: number) => {
      const fileName = path.basename(file.filePath, '.md');
      console.log(`   ğŸ“„ Processing: ${fileName}`);
      
      const processed = processFileWithSourceRenumbering(
        file.content,
        fileName,
        currentStartingNumber
      );
      
      // íŒŒì¼ êµ¬ë¶„ì ì¶”ê°€ (ì²« ë²ˆì§¸ íŒŒì¼ ì œì™¸)
      if (index > 0) {
        combinedContent += '\n\n---\n\n';
      }
      
      combinedContent += processed.content;
      allSources.push(...processed.sources);
      
      // ë‹¤ìŒ íŒŒì¼ì˜ ì‹œì‘ ë²ˆí˜¸ ì—…ë°ì´íŠ¸
      currentStartingNumber += processed.sources.length;
      
      console.log(`   âœ… ${fileName}: ${processed.sources.length} sources, next starts at [${currentStartingNumber}]`);
    });
    
    console.log(`ğŸ“Š Total sources collected for ${group.dimension}: ${allSources.length}`);
    
    return {
      files: group.files,
      dimension: group.dimension,
      combinedContent,
      allSources
    };
  }
  
  /**
   * ì†ŒìŠ¤ ì„¹ì…˜ì„ ìƒì„±í•˜ëŠ” í•¨ìˆ˜
   */
  export function generateSourcesSection(sources: SourceInfo[]): string {
    if (sources.length === 0) return '';
    
    let sourcesSection = '\n\n---\n\n## Sources\n\n';
    
    sources.forEach(source => {
      if (source.title && source.title !== source.url) {
        sourcesSection += `${source.newId}. ${source.title} - ${source.url}\n`;
      } else {
        sourcesSection += `${source.newId}. ${source.url}\n`;
      }
    });
    
    // ì›ë³¸ íŒŒì¼ ì •ë³´ë„ ì¶”ê°€
    sourcesSection += '\n### ë°ì´í„° ì¶œì²˜ë³„ ì†ŒìŠ¤ ë²ˆí˜¸\n\n';
    const fileGroups = new Map<string, number[]>();
    
    sources.forEach(source => {
      if (!fileGroups.has(source.fileName)) {
        fileGroups.set(source.fileName, []);
      }
      fileGroups.get(source.fileName)!.push(source.newId);
    });
    
    fileGroups.forEach((sourceNumbers, fileName) => {
      const sortedNumbers = sourceNumbers.sort((a, b) => a - b);
      sourcesSection += `- **${fileName}**: [${sortedNumbers.join('], [')}]\n`;
    });
    
    return sourcesSection;
  }
  
/**
 * íŒŒì¼ ë‚´ìš©ì„ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜ (comprehensive-report-generator.tsì—ì„œ ì‚¬ìš©)
 */
export async function processFileContent(filePath: string): Promise<ProcessedFileContent> {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    const fileName = path.basename(filePath, '.md');
    
    return processFileWithSourceRenumbering(content, fileName, 1);
  } catch (error) {
    console.error(`Error processing file ${filePath}:`, error);
    return {
      content: '',
      sources: []
    };
  }
}